name: Deploy Training Form Application

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
        - development

env:
  PYTHON_VERSION: '3.11'
  
jobs:
  test:
    runs-on: self-hosted
    name: Run Unit Tests
    
    steps:
    - name: Pre-cleanup workspace
      run: |
        Write-Host "Cleaning up workspace before checkout..."
        
        # Stop any running Flask processes
        try {
            $flaskProcesses = Get-WmiObject Win32_Process | Where-Object { 
                $_.CommandLine -and (
                    $_.CommandLine -match "start_production\.py" -or 
                    $_.CommandLine -match "start_staging\.py" -or
                    $_.CommandLine -match "main\.py.*port.*500" -or
                    $_.CommandLine -match "flask.*run"
                )
            }
            
            if ($flaskProcesses) {
                Write-Host "Found Flask processes to terminate:"
                $flaskProcesses | ForEach-Object { 
                    Write-Host "  PID: $($_.ProcessId), Command: $($_.CommandLine)"
                    Stop-Process -Id $_.ProcessId -Force -ErrorAction SilentlyContinue
                }
                Start-Sleep -Seconds 3
            }
        } catch {
            Write-Host "Error checking Flask processes: $_"
        }
        
        # Kill processes using common ports
        $ports = @(5000, 5001)
        foreach ($port in $ports) {
            try {
                $procs = netstat -ano | Where-Object { $_ -match ":$port.*LISTENING" }
                if ($procs) {
                    $processIds = ($procs | ForEach-Object { ($_ -split '\s+')[-1] }) | Sort-Object -Unique
                    foreach ($processId in $processIds) {
                        if ($processId -match '^\d+$') {
                            Write-Host "Killing process $processId using port $port"
                            Stop-Process -Id $processId -Force -ErrorAction SilentlyContinue
                        }
                    }
                }
            } catch {
                Write-Host "Error checking port $port : $_"
            }
        }
        
        # Wait for file handles to be released
        Start-Sleep -Seconds 5
        
        # Force unlock common log files
        $logFiles = @("production.log", "production_direct.log", "production_direct_error.log", "staging_direct.log", "staging_error.log")
        foreach ($logFile in $logFiles) {
            if (Test-Path $logFile) {
                try {
                    Remove-Item $logFile -Force -ErrorAction SilentlyContinue
                    Write-Host "Removed log file: $logFile"
                } catch {
                    Write-Host "Could not remove $logFile : $_"
                }
            }
        }
        
        Write-Host "Pre-cleanup completed"
      shell: powershell
      continue-on-error: true
      
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~\AppData\Local\pip\Cache
          ~\AppData\Roaming\pip\Cache
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
        enableCrossOsArchive: false
          
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        
    - name: Set up test environment
      run: |
        # Copy template and create test environment file using PowerShell to avoid encoding issues
        Copy-Item "env.example" ".env.test" -Force
        # Add test-specific configuration
        Add-Content -Path ".env.test" -Value "USE_SQLITE=True" -Encoding UTF8
        Add-Content -Path ".env.test" -Value "DEBUG=True" -Encoding UTF8  
        Add-Content -Path ".env.test" -Value "SECRET_KEY=test-secret-key" -Encoding UTF8
        Add-Content -Path ".env.test" -Value "FLASK_ENV=test" -Encoding UTF8
        Copy-Item ".env.test" ".env" -Force
      shell: powershell
        
    - name: Run database setup for tests
      run: python setup_db.py
      
    - name: Run unit tests
      run: |
        echo "Skipping JavaScript e2e tests in tests/e2e/ (out of date)"
        echo "No Python unit tests found in tests/ directory"
        echo "Running simple application validation tests instead..."
        python simple_test.py
        
  deploy-development:
    runs-on: self-hosted
    needs: test
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'development')
    name: Deploy to Development (Local)
    
    steps:
    - name: Pre-cleanup workspace
      run: |
        Write-Host "Cleaning up workspace before checkout..."
        
        # Stop any running Flask processes
        try {
            $flaskProcesses = Get-WmiObject Win32_Process | Where-Object { 
                $_.CommandLine -and (
                    $_.CommandLine -match "start_production\.py" -or 
                    $_.CommandLine -match "start_staging\.py" -or
                    $_.CommandLine -match "main\.py.*port.*500" -or
                    $_.CommandLine -match "flask.*run"
                )
            }
            
            if ($flaskProcesses) {
                Write-Host "Found Flask processes to terminate:"
                $flaskProcesses | ForEach-Object { 
                    Write-Host "  PID: $($_.ProcessId), Command: $($_.CommandLine)"
                    Stop-Process -Id $_.ProcessId -Force -ErrorAction SilentlyContinue
                }
                Start-Sleep -Seconds 3
            }
        } catch {
            Write-Host "Error checking Flask processes: $_"
        }
        
        # Kill processes using common ports
        $ports = @(5000, 5001)
        foreach ($port in $ports) {
            try {
                $procs = netstat -ano | Where-Object { $_ -match ":$port.*LISTENING" }
                if ($procs) {
                    $processIds = ($procs | ForEach-Object { ($_ -split '\s+')[-1] }) | Sort-Object -Unique
                    foreach ($processId in $processIds) {
                        if ($processId -match '^\d+$') {
                            Write-Host "Killing process $processId using port $port"
                            Stop-Process -Id $processId -Force -ErrorAction SilentlyContinue
                        }
                    }
                }
            } catch {
                Write-Host "Error checking port $port : $_"
            }
        }
        
        # Wait for file handles to be released
        Start-Sleep -Seconds 5
        
        # Force unlock common log files
        $logFiles = @("production.log", "production_direct.log", "production_direct_error.log", "staging_direct.log", "staging_error.log")
        foreach ($logFile in $logFiles) {
            if (Test-Path $logFile) {
                try {
                    Remove-Item $logFile -Force -ErrorAction SilentlyContinue
                    Write-Host "Removed log file: $logFile"
                } catch {
                    Write-Host "Could not remove $logFile : $_"
                }
            }
        }
        
        Write-Host "Pre-cleanup completed"
      shell: powershell
      continue-on-error: true
      
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~\AppData\Local\pip\Cache
          ~\AppData\Roaming\pip\Cache
        key: ${{ runner.os }}-pip-dev-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-dev-
          ${{ runner.os }}-pip-
        enableCrossOsArchive: false
        
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        
    - name: Create development environment file
      run: |
        Write-Host "Creating .env.development file..."
        "DEBUG=True" | Out-File -FilePath ".env.development" -Encoding UTF8
        "SECRET_KEY=${{ secrets.DEV_SECRET_KEY }}" | Out-File -FilePath ".env.development" -Append -Encoding UTF8
        "USE_SQLITE=True" | Out-File -FilePath ".env.development" -Append -Encoding UTF8
        "DB_PATH=training_forms.db" | Out-File -FilePath ".env.development" -Append -Encoding UTF8
        "UPLOAD_FOLDER=uploads" | Out-File -FilePath ".env.development" -Append -Encoding UTF8
        "LDAP_HOST=${{ secrets.LDAP_HOST }}" | Out-File -FilePath ".env.development" -Append -Encoding UTF8
        "LDAP_PORT=${{ secrets.LDAP_PORT }}" | Out-File -FilePath ".env.development" -Append -Encoding UTF8
        "LDAP_BASE_DN=${{ secrets.LDAP_BASE_DN }}" | Out-File -FilePath ".env.development" -Append -Encoding UTF8
        "LDAP_DOMAIN=${{ secrets.LDAP_DOMAIN }}" | Out-File -FilePath ".env.development" -Append -Encoding UTF8
        "LDAP_USE_SSL=False" | Out-File -FilePath ".env.development" -Append -Encoding UTF8
        "FLASK_ENV=development" | Out-File -FilePath ".env.development" -Append -Encoding UTF8
        Copy-Item ".env.development" ".env" -Force
      shell: powershell
        
    - name: Run database migrations
      run: python -m alembic upgrade head
      
    - name: Set up database
      run: python setup_db.py
      
    - name: Create uploads directory
      run: |
        if (!(Test-Path "uploads")) { New-Item -ItemType Directory -Path "uploads" }
      shell: powershell
        
    - name: Test application configuration
      run: |
        python -c "
        from config import DATABASE_URL, USE_SQLITE
        print('Environment: Development')
        print(f'Database: {DATABASE_URL}')
        print(f'SQLite: {USE_SQLITE}')
        "
        
    - name: Restart application service (development)
      run: |
        # Stop existing process if running
        Get-Process -Name "python" -ErrorAction SilentlyContinue | Where-Object { $_.CommandLine -match "port.*5000" } | Stop-Process -Force
        # Start application in background
        Start-Process -FilePath "python" -ArgumentList "main.py", "--port", "5000", "--no-debug" -WindowStyle Hidden -WorkingDirectory (Get-Location)
      shell: powershell
        
    - name: Verify deployment
      run: |
        Write-Host "Waiting for development application to start..."
        Start-Sleep -Seconds 30
        try {
            $response = Invoke-WebRequest -Uri "http://localhost:5000" -TimeoutSec 10 -UseBasicParsing
            Write-Host "Development Status: $($response.StatusCode)"
        } catch {
            Write-Host "Development service starting... $($_.Exception.Message)"
        }
      shell: powershell

  deploy-staging:
    runs-on: self-hosted
    needs: test
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    name: Deploy to Staging Environment
    environment: staging
    
    steps:
    - name: Pre-cleanup workspace
      run: |
        Write-Host "Cleaning up workspace before checkout..."
        
        # Stop any running Flask processes
        try {
            $flaskProcesses = Get-WmiObject Win32_Process | Where-Object { 
                $_.CommandLine -and (
                    $_.CommandLine -match "start_production\.py" -or 
                    $_.CommandLine -match "start_staging\.py" -or
                    $_.CommandLine -match "main\.py.*port.*500" -or
                    $_.CommandLine -match "flask.*run"
                )
            }
            
            if ($flaskProcesses) {
                Write-Host "Found Flask processes to terminate:"
                $flaskProcesses | ForEach-Object { 
                    Write-Host "  PID: $($_.ProcessId), Command: $($_.CommandLine)"
                    Stop-Process -Id $_.ProcessId -Force -ErrorAction SilentlyContinue
                }
                Start-Sleep -Seconds 3
            }
        } catch {
            Write-Host "Error checking Flask processes: $_"
        }
        
        # Kill processes using common ports
        $ports = @(5000, 5001)
        foreach ($port in $ports) {
            try {
                $procs = netstat -ano | Where-Object { $_ -match ":$port.*LISTENING" }
                if ($procs) {
                    $processIds = ($procs | ForEach-Object { ($_ -split '\s+')[-1] }) | Sort-Object -Unique
                    foreach ($processId in $processIds) {
                        if ($processId -match '^\d+$') {
                            Write-Host "Killing process $processId using port $port"
                            Stop-Process -Id $processId -Force -ErrorAction SilentlyContinue
                        }
                    }
                }
            } catch {
                Write-Host "Error checking port $port : $_"
            }
        }
        
        # Wait for file handles to be released
        Start-Sleep -Seconds 5
        
        # Force unlock common log files
        $logFiles = @("production.log", "production_direct.log", "production_direct_error.log", "staging_direct.log", "staging_error.log")
        foreach ($logFile in $logFiles) {
            if (Test-Path $logFile) {
                try {
                    Remove-Item $logFile -Force -ErrorAction SilentlyContinue
                    Write-Host "Removed log file: $logFile"
                } catch {
                    Write-Host "Could not remove $logFile : $_"
                }
            }
        }
        
        Write-Host "Pre-cleanup completed"
      shell: powershell
      continue-on-error: true
      
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~\AppData\Local\pip\Cache
          ~\AppData\Roaming\pip\Cache
        key: ${{ runner.os }}-pip-staging-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-staging-
          ${{ runner.os }}-pip-
        enableCrossOsArchive: false
        
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        
    - name: Create staging environment file
      run: |
        Write-Host "Creating .env.staging file..."
        "DEBUG=False" | Out-File -FilePath ".env.staging" -Encoding UTF8
        "SECRET_KEY=${{ secrets.STAGING_SECRET_KEY }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "USE_SQLITE=False" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "DB_HOST=${{ secrets.STAGING_DB_HOST }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "DB_PORT=${{ secrets.STAGING_DB_PORT }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "DB_NAME=${{ secrets.STAGING_DB_NAME }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "DB_USER=${{ secrets.STAGING_DB_USER }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "UPLOAD_FOLDER=uploads_staging" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "NETWORK_STORAGE_PATH=${{ secrets.STAGING_NETWORK_STORAGE_PATH }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "LDAP_HOST=${{ secrets.LDAP_HOST }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "LDAP_PORT=${{ secrets.LDAP_PORT }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "LDAP_BASE_DN=${{ secrets.LDAP_BASE_DN }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "LDAP_DOMAIN=${{ secrets.LDAP_DOMAIN }}" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "LDAP_USE_SSL=False" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        "FLASK_ENV=staging" | Out-File -FilePath ".env.staging" -Append -Encoding UTF8
        Copy-Item ".env.staging" ".env" -Force
      shell: powershell
        
    - name: Test staging database connection
      run: |
        python -c "from models import engine; conn = engine.connect(); print('PASS: Staging database connection successful'); conn.close()"
      
    - name: Check for pending schema changes
      run: |
        echo "Checking database migration status..."
        python -m alembic current -v
        
    - name: Run database migrations on staging
      run: python -m alembic upgrade head
      
    - name: Create staging uploads directory
      run: |
        if (!(Test-Path "uploads_staging")) { New-Item -ItemType Directory -Path "uploads_staging" }
      shell: powershell
        
    - name: Test staging application configuration
      run: |
        python -c "
        from config import DATABASE_URL, USE_SQLITE, DB_NAME
        print('Environment: Staging')
        print(f'Database: {DB_NAME}')
        print(f'SQLite: {USE_SQLITE}')
        "
        
    - name: Stop existing staging service
      run: |
        Write-Host "Stopping any existing staging services..."
        
        # Kill any processes using port 5001
        try {
            $netstatOutput = netstat -ano 2>$null
            $processesOnPort = $netstatOutput | Where-Object { $_ -match ":5001" }
            if ($processesOnPort) {
                Write-Host "Processes using port 5001:"
                $processesOnPort | ForEach-Object { Write-Host $_ }
                
                # Extract PIDs and kill them
                $processIds = ($processesOnPort | ForEach-Object { ($_ -split '\s+')[-1] }) | Sort-Object -Unique
                foreach ($processId in $processIds) {
                    if ($processId -match '^\d+$') {
                        Write-Host "Killing process PID: $processId"
                        Stop-Process -Id $processId -Force -ErrorAction SilentlyContinue
                    }
                }
            } else {
                Write-Host "No processes found using port 5001"
            }
        } catch {
            Write-Host "Error checking port 5001: $_"
        }
        
        # Also stop Python processes that match staging pattern
        try {
            $allPythonProcesses = Get-Process -Name "python" -ErrorAction SilentlyContinue
            $stagingProcesses = @()
            
            foreach ($proc in $allPythonProcesses) {
                try {
                    $cmdLine = (Get-WmiObject Win32_Process -Filter "ProcessId = $($proc.Id)" -ErrorAction SilentlyContinue).CommandLine
                    if ($cmdLine -and ($cmdLine -match "start_staging" -or $cmdLine -match "port.*5001")) {
                        $stagingProcesses += $proc
                    }
                } catch {
                    # Ignore errors accessing command line
                }
            }
            
            if ($stagingProcesses.Count -gt 0) {
                Write-Host "Found staging Python processes:"
                $stagingProcesses | Format-Table Id, ProcessName, StartTime -AutoSize
                $stagingProcesses | Stop-Process -Force -ErrorAction SilentlyContinue
                Write-Host "Stopped staging processes"
            } else {
                Write-Host "No staging Python processes found"
            }
        } catch {
            Write-Host "Error checking Python processes: $_"
        }
        
        Start-Sleep -Seconds 5
        Write-Host "Process cleanup completed successfully"
        exit 0
      shell: powershell
        
    - name: Test staging startup script
      run: |
        Write-Host "Testing staging startup script..."
        python -c "import scripts.start_staging; print('PASS: Startup script can be imported')"
      shell: powershell
        
    - name: Start and verify staging service
      run: |
        Write-Host "Starting staging application..."
        
        # Clean up any old processes on port 5001
        $existingProcesses = netstat -ano | Where-Object { $_ -match ":5001" }
        if ($existingProcesses) {
            Write-Host "Found existing processes on port 5001, cleaning up..."
            $processIds = ($existingProcesses | ForEach-Object { ($_ -split '\s+')[-1] }) | Sort-Object -Unique
            foreach ($processId in $processIds) {
                if ($processId -match '^\d+$') {
                    Stop-Process -Id $processId -Force -ErrorAction SilentlyContinue
                }
            }
            Start-Sleep -Seconds 2
        }
        
        # Start the Flask application directly
        $env:FLASK_ENV = "staging"
        $env:PYTHONUNBUFFERED = "1"
        
        $pythonExe = (Get-Command python).Path
        $scriptPath = "scripts\start_staging.py"
        $logFile = "staging_direct.log"
        
        Write-Host "Starting Flask app with Python: $pythonExe"
        Write-Host "Script: $scriptPath"
        
        # Use Start-Process to launch Python in background
        $processArgs = @{
            FilePath = $pythonExe
            ArgumentList = $scriptPath
            WorkingDirectory = Get-Location
            RedirectStandardOutput = $logFile
            RedirectStandardError = "staging_error.log"
            WindowStyle = "Hidden"
            PassThru = $true
        }
        
        $proc = Start-Process @processArgs
        
        if ($proc) {
            Write-Host "Started Flask process with PID: $($proc.Id)"
            
            # Save PID for reference
            $proc.Id | Out-File -FilePath "staging_flask_pid.txt"
            
            # Wait for app to start
            $attempts = 0
            $maxAttempts = 12
            $started = $false
            
            while ($attempts -lt $maxAttempts -and -not $started) {
                Start-Sleep -Seconds 5
                $attempts++
                
                Write-Host "Checking Flask status (attempt $attempts/$maxAttempts)..."
                
                # Check if process is still running
                $stillRunning = Get-Process -Id $proc.Id -ErrorAction SilentlyContinue
                if (-not $stillRunning) {
                    Write-Host "ERROR: Flask process has exited!"
                    if (Test-Path $logFile) {
                        Write-Host "Output log:"
                        Get-Content $logFile
                    }
                    if (Test-Path "staging_error.log") {
                        Write-Host "Error log:"
                        Get-Content "staging_error.log"
                    }
                    exit 1
                }
                
                # Try to connect
                try {
                    $response = Invoke-WebRequest -Uri "http://localhost:5001" -UseBasicParsing -TimeoutSec 5 -ErrorAction Stop
                    Write-Host "SUCCESS: Flask is responding!"
                    $started = $true
                } catch {
                    Write-Host "Not ready yet..."
                    
                    # Show recent log entries
                    if (Test-Path $logFile) {
                        $recentLog = Get-Content $logFile -Tail 5
                        if ($recentLog) {
                            Write-Host "Recent log:"
                            $recentLog | ForEach-Object { Write-Host "  $_" }
                        }
                    }
                }
            }
            
            if ($started) {
                Write-Host "PASS: Staging Flask application is running on port 5001"
                
                # Double-check port is listening
                $listening = netstat -ano | Where-Object { $_ -match ":5001.*LISTENING" }
                if ($listening) {
                    Write-Host "Confirmed port 5001 is listening"
                }
            } else {
                Write-Host "FAIL: Flask did not start in time"
                exit 1
            }
            
        } else {
            Write-Host "FAIL: Could not start Flask process"
            exit 1
        }
      shell: powershell
        
    - name: Run integration tests on staging
      run: |
        Write-Host "Checking if staging Flask is still running..."
        
        # Check if we have a saved PID
        $pidFile = "staging_flask_pid.txt"
        if (Test-Path $pidFile) {
            $savedPid = Get-Content $pidFile
            Write-Host "Checking for Flask process with PID: $savedPid"
            
            $flaskProcess = Get-Process -Id $savedPid -ErrorAction SilentlyContinue
            if ($flaskProcess) {
                Write-Host "Flask process is still running"
            } else {
                Write-Host "Flask process has stopped, need to restart it"
                
                # Restart Flask
                $env:FLASK_ENV = "staging"
                $env:PYTHONUNBUFFERED = "1"
                
                $pythonExe = (Get-Command python).Path
                $scriptPath = "scripts\start_staging.py"
                
                Write-Host "Restarting Flask..."
                $proc = Start-Process -FilePath $pythonExe -ArgumentList $scriptPath -WorkingDirectory (Get-Location) -WindowStyle Hidden -PassThru
                
                if ($proc) {
                    $proc.Id | Out-File -FilePath $pidFile -Force
                    Write-Host "Flask restarted with PID: $($proc.Id)"
                    
                    # Wait for it to start
                    Start-Sleep -Seconds 10
                    
                    # Verify it's responding
                    try {
                        $response = Invoke-WebRequest -Uri "http://localhost:5001" -UseBasicParsing -TimeoutSec 5 -ErrorAction Stop
                        Write-Host "Flask is responding after restart"
                    } catch {
                        Write-Host "ERROR: Flask not responding after restart: $_"
                        exit 1
                    }
                } else {
                    Write-Host "ERROR: Failed to restart Flask"
                    exit 1
                }
            }
        } else {
            Write-Host "No PID file found, starting Flask fresh..."
            
            # Start Flask
            $env:FLASK_ENV = "staging"
            $env:PYTHONUNBUFFERED = "1"
            
            $pythonExe = (Get-Command python).Path
            $scriptPath = "scripts\start_staging.py"
            
            $proc = Start-Process -FilePath $pythonExe -ArgumentList $scriptPath -WorkingDirectory (Get-Location) -WindowStyle Hidden -PassThru
            
            if ($proc) {
                $proc.Id | Out-File -FilePath $pidFile -Force
                Write-Host "Flask started with PID: $($proc.Id)"
                Start-Sleep -Seconds 10
            } else {
                Write-Host "ERROR: Failed to start Flask"
                exit 1
            }
        }
        
        # Check port status
        Write-Host "`nPort 5001 status:"
        netstat -ano | Where-Object { $_ -match ":5001.*LISTENING" } | ForEach-Object { Write-Host "  $_" }
        
        Write-Host "`nRunning integration tests..."
      shell: powershell
      
    - name: Execute staging integration tests
      run: |
        echo "Running integration tests on staging environment..."
        python -c "
        import requests
        import sys
        import time
        
        # Test basic application health
        try:
            r = requests.get('http://localhost:5001', timeout=15)
            if r.status_code == 200:
                print('PASS: Staging application is responding')
            else:
                print(f'FAIL: Staging health check failed: {r.status_code}')
                sys.exit(1)
        except Exception as e:
            print(f'FAIL: Staging application not accessible: {e}')
            sys.exit(1)
        
        # Test database connectivity through API
        try:
            r = requests.get('http://localhost:5001/api/employees', timeout=15)
            if r.status_code == 200:
                print('PASS: Staging database connectivity test passed')
            else:
                print(f'WARNING: Database connectivity test status: {r.status_code}')
        except Exception as e:
            print(f'WARNING: Database connectivity test failed: {e}')
        
        print('PASS: All staging tests completed successfully')
        "
        
    - name: Run additional staging validation
      run: |
        echo "Running additional staging validation..."
        # Test migration status
        python -m alembic current -v
        
        # Verify key application components
        python -c "
        from models import get_admin_by_email
        from config import DATABASE_URL, DB_NAME
        print(f'PASS: Database models loaded successfully')
        print(f'PASS: Connected to staging database: {DB_NAME}')
        
        # Test a simple database operation
        admin = get_admin_by_email('harry@test.com')
        if admin:
            print('PASS: Database operations working correctly')
        else:
            print('WARNING: No admin users found (this might be expected for a fresh staging environment)')
        "

  deploy-production:
    runs-on: self-hosted
    needs: [test, deploy-staging]
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    name: Deploy to Production
    environment: production
    
    steps:
    - name: Pre-cleanup workspace
      run: |
        Write-Host "Cleaning up workspace before checkout..."
        
        # Stop any running Flask processes
        try {
            $flaskProcesses = Get-WmiObject Win32_Process | Where-Object { 
                $_.CommandLine -and (
                    $_.CommandLine -match "start_production\.py" -or 
                    $_.CommandLine -match "start_staging\.py" -or
                    $_.CommandLine -match "main\.py.*port.*500" -or
                    $_.CommandLine -match "flask.*run"
                )
            }
            
            if ($flaskProcesses) {
                Write-Host "Found Flask processes to terminate:"
                $flaskProcesses | ForEach-Object { 
                    Write-Host "  PID: $($_.ProcessId), Command: $($_.CommandLine)"
                    Stop-Process -Id $_.ProcessId -Force -ErrorAction SilentlyContinue
                }
                Start-Sleep -Seconds 3
            }
        } catch {
            Write-Host "Error checking Flask processes: $_"
        }
        
        # Kill processes using common ports
        $ports = @(5000, 5001)
        foreach ($port in $ports) {
            try {
                $procs = netstat -ano | Where-Object { $_ -match ":$port.*LISTENING" }
                if ($procs) {
                    $processIds = ($procs | ForEach-Object { ($_ -split '\s+')[-1] }) | Sort-Object -Unique
                    foreach ($processId in $processIds) {
                        if ($processId -match '^\d+$') {
                            Write-Host "Killing process $processId using port $port"
                            Stop-Process -Id $processId -Force -ErrorAction SilentlyContinue
                        }
                    }
                }
            } catch {
                Write-Host "Error checking port $port : $_"
            }
        }
        
        # Wait for file handles to be released
        Start-Sleep -Seconds 5
        
        # Force unlock common log files
        $logFiles = @("production.log", "production_direct.log", "production_direct_error.log", "staging_direct.log", "staging_error.log")
        foreach ($logFile in $logFiles) {
            if (Test-Path $logFile) {
                try {
                    Remove-Item $logFile -Force -ErrorAction SilentlyContinue
                    Write-Host "Removed log file: $logFile"
                } catch {
                    Write-Host "Could not remove $logFile : $_"
                }
            }
        }
        
        Write-Host "Pre-cleanup completed"
      shell: powershell
      continue-on-error: true
      
    - name: Debug - Show runner environment
      run: |
        Write-Host "=== RUNNER ENVIRONMENT DEBUG ==="
        Write-Host "Computer Name: $env:COMPUTERNAME"
        Write-Host "User: $env:USERNAME"
        Write-Host "Working Directory: $(Get-Location)"
        Write-Host "IP Address: $(Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias 'Ethernet*' | Select-Object -First 1 | Select-Object -ExpandProperty IPAddress)"
        Write-Host "================================"
      shell: powershell
      
    - name: Verify target server
      run: |
        Write-Host "Checking if we're on the target production server..."
        $currentComputer = $env:COMPUTERNAME
        $targetServer = "azulimpbi01"
        
        Write-Host "Current computer: $currentComputer"
        Write-Host "Target server: $targetServer"
        
        if ($currentComputer.ToLower() -eq $targetServer.ToLower()) {
            Write-Host "PASS: Running on target production server"
        } else {
            Write-Host "WARNING: Not running on target server $targetServer"
            Write-Host "This deployment will run locally instead of on the production server"
            Write-Host "To deploy to $targetServer, you need either:"
            Write-Host "1. A GitHub Actions runner installed on $targetServer, OR"
            Write-Host "2. Remote deployment configuration to connect to $targetServer"
        }
      shell: powershell
      
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~\AppData\Local\pip\Cache
          ~\AppData\Roaming\pip\Cache
        key: ${{ runner.os }}-pip-prod-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-prod-
          ${{ runner.os }}-pip-
        enableCrossOsArchive: false
        
    - name: Install dependencies
      run: |
        # Use the same Python that the service will use
        $pythonExe = (Get-Command python).Path
        Write-Host "Installing to Python: $pythonExe"
        & $pythonExe -m pip install -r requirements.txt
        
    - name: Create production environment
      run: |
        Write-Host "Creating production environment..."
        Write-Host "Database: ${{ secrets.PROD_DB_NAME }} on ${{ secrets.PROD_DB_HOST }}"
        
        # Clean slate
        Remove-Item -Path ".env*" -Force -ErrorAction SilentlyContinue
        
        # Create production .env
        "DEBUG=False" | Out-File -FilePath ".env" -Encoding UTF8
        "SECRET_KEY=${{ secrets.PROD_SECRET_KEY }}" | Out-File -FilePath ".env" -Append -Encoding UTF8
        "USE_SQLITE=False" | Out-File -FilePath ".env" -Append -Encoding UTF8
        "DB_HOST=${{ secrets.PROD_DB_HOST }}" | Out-File -FilePath ".env" -Append -Encoding UTF8
        "DB_PORT=${{ secrets.PROD_DB_PORT }}" | Out-File -FilePath ".env" -Append -Encoding UTF8
        "DB_NAME=${{ secrets.PROD_DB_NAME }}" | Out-File -FilePath ".env" -Append -Encoding UTF8
        "DB_USER=${{ secrets.PROD_DB_USER }}" | Out-File -FilePath ".env" -Append -Encoding UTF8
        "DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}" | Out-File -FilePath ".env" -Append -Encoding UTF8
        "UPLOAD_FOLDER=c:/TrainingAppData/Uploads" | Out-File -FilePath ".env" -Append -Encoding UTF8
        "FLASK_ENV=production" | Out-File -FilePath ".env" -Append -Encoding UTF8
        "SEQ_API_KEY=${{ secrets.SEQ_API_KEY }}" | Out-File -FilePath ".env" -Append -Encoding UTF8
        "SEQ_AUTH_REQUIRED=false" | Out-File -FilePath ".env" -Append -Encoding UTF8
        
        Write-Host "PASS: Environment configured"
      shell: powershell
        
    - name: Test database connection
      run: |
        Write-Host "Testing database connection..."
        python -c "from models import engine; conn = engine.connect(); print('PASS: Database connection successful'); conn.close()"
        
    - name: Run migrations
      run: |
        Write-Host "Running database migrations..."
        python -m alembic upgrade head
        Write-Host "PASS: Migrations completed"
      shell: powershell
      
    - name: Create production uploads directory
      run: |
        Write-Host "Creating production uploads directory..."
        $uploadsDir = "c:\TrainingAppData\Uploads"
        if (-not (Test-Path $uploadsDir)) {
            New-Item -ItemType Directory -Path $uploadsDir -Force
            Write-Host "PASS: Created uploads directory: $uploadsDir"
        } else {
            Write-Host "PASS: Uploads directory already exists: $uploadsDir"
        }
      shell: powershell
      
    - name: Stop existing production service
      run: |
        Write-Host "Stopping existing Training Form Application service..."
        
        # Use our service management script to stop any existing service
        $scriptPath = "scripts\manage_production_service.ps1"
        if (Test-Path $scriptPath) {
            try {
                & powershell.exe -ExecutionPolicy Bypass -File $scriptPath -Action stop
                Write-Host "PASS: Service stopped using management script"
            } catch {
                Write-Host "WARNING: Service management script failed: $_"
            }
        }
        
        # Fallback: Kill any processes using port 5000
        $procs = netstat -ano | Where-Object { $_ -match ":5000.*LISTENING" }
        if ($procs) {
            $processIds = ($procs | ForEach-Object { ($_ -split '\s+')[-1] }) | Sort-Object -Unique
            foreach ($processId in $processIds) {
                if ($processId -match '^\d+$') {
                    Stop-Process -Id $processId -Force -ErrorAction SilentlyContinue
                    Write-Host "Stopped process $processId"
                }
            }
        }
        Start-Sleep -Seconds 3
      shell: powershell
        
    - name: Run production diagnostics
      run: |
        Write-Host "Running production deployment diagnostics..."
        python scripts\diagnose_production.py
      shell: powershell

    - name: Install and start production service
      run: |
        Write-Host "Installing and starting Training Form Application as a Windows service..."
        
        $scriptPath = "scripts\manage_production_service.ps1"
        $currentDir = Get-Location
        
        Write-Host "Using service management script: $scriptPath"
        Write-Host "Working directory: $currentDir"
        
        # Ensure we have absolute paths
        $absoluteScriptPath = Join-Path $currentDir $scriptPath
        $absoluteCurrentDir = $currentDir.Path
        
        Write-Host "Absolute script path: $absoluteScriptPath"
        Write-Host "Absolute working directory: $absoluteCurrentDir"
        
        # Verify the script exists
        if (-not (Test-Path $absoluteScriptPath)) {
            Write-Host "ERROR: Service management script not found at $absoluteScriptPath"
            exit 1
        }
        
        # Track if service installation was successful
        $serviceInstalled = $false
        $serviceStarted = $false
        
        try {
            Write-Host "Attempting service installation..."
            
            # Install the service with detailed output capture
            $installOutput = & powershell.exe -ExecutionPolicy Bypass -File $absoluteScriptPath -Action install -WorkingDir $absoluteCurrentDir 2>&1
            $installExitCode = $LASTEXITCODE
            
            Write-Host "Install command output:"
            Write-Host $installOutput
            Write-Host "Install exit code: $installExitCode"
            
            if ($installExitCode -eq 0) {
                Write-Host "Service installation successful"
                $serviceInstalled = $true
                
                # Try to start the service
                Write-Host "Attempting to start service..."
                $startOutput = & powershell.exe -ExecutionPolicy Bypass -File $absoluteScriptPath -Action start -WorkingDir $absoluteCurrentDir 2>&1
                $startExitCode = $LASTEXITCODE
                
                Write-Host "Start command output:"
                Write-Host $startOutput
                Write-Host "Start exit code: $startExitCode"
                
                if ($startExitCode -eq 0) {
                    Write-Host "Service started successfully"
                    $serviceStarted = $true
                } else {
                    Write-Host "WARNING: Service installation succeeded but start failed"
                }
            } else {
                Write-Host "Service installation failed with exit code: $installExitCode"
            }
            
        } catch {
            Write-Host "EXCEPTION during service installation: $($_.Exception.Message)"
            Write-Host "Full exception: $_"
        }
        
        # If service installation or startup failed, use direct startup
        if (-not $serviceInstalled -or -not $serviceStarted) {
            Write-Host ""
            Write-Host "=== FALLBACK: Starting Flask directly ==="
            
            # Get Python executable
            $pythonExe = (Get-Command python -ErrorAction SilentlyContinue).Path
            if (-not $pythonExe) {
                Write-Host "ERROR: Python executable not found"
                exit 1
            }
            
            $startScript = Join-Path $currentDir "scripts\start_production.py"
            
            # Verify start script exists
            if (-not (Test-Path $startScript)) {
                Write-Host "ERROR: Start script not found at $startScript"
                exit 1
            }
            
            Write-Host "Python executable: $pythonExe"
            Write-Host "Start script: $startScript"
            Write-Host "Working directory: $currentDir"
            
            # Set environment variables for the process
            $env:FLASK_ENV = "production"
            $env:PYTHONUNBUFFERED = "1"
            
            # Start the process with more robust error handling
            try {
                $processArgs = @{
                    FilePath = $pythonExe
                    ArgumentList = "`"$startScript`""
                    WorkingDirectory = $currentDir
                    WindowStyle = "Hidden"
                    PassThru = $true
                    RedirectStandardOutput = "production_direct.log"
                    RedirectStandardError = "production_direct_error.log"
                }
                
                Write-Host "Starting process with arguments:"
                Write-Host "  FilePath: $($processArgs.FilePath)"
                Write-Host "  Arguments: $($processArgs.ArgumentList)"
                Write-Host "  WorkingDirectory: $($processArgs.WorkingDirectory)"
                
                $proc = Start-Process @processArgs
                
                if ($proc -and $proc.Id) {
                    Write-Host "PASS: Flask started directly with Process ID: $($proc.Id)"
                    
                    # Save PID for later reference
                    $proc.Id | Out-File -FilePath "production_direct.pid" -Force
                    
                    # Wait a moment to ensure it started properly
                    Start-Sleep -Seconds 5
                    
                    # Check if process is still running
                    $stillRunning = Get-Process -Id $proc.Id -ErrorAction SilentlyContinue
                    if ($stillRunning) {
                        Write-Host "PASS: Process is still running after 5 seconds"
                        
                        # Check for errors in log files
                        Start-Sleep -Seconds 10  # Wait a bit more for any startup errors
                        if (Test-Path "production_direct_error.log") {
                            $errorContent = Get-Content "production_direct_error.log" -ErrorAction SilentlyContinue
                            if ($errorContent) {
                                Write-Host "ERROR: Flask startup errors detected:"
                                $errorContent | ForEach-Object { Write-Host "  $_" }
                                exit 1
                            }
                        }
                    } else {
                        Write-Host "ERROR: Process exited after startup"
                        if (Test-Path "production_direct_error.log") {
                            Write-Host "Error log content:"
                            Get-Content "production_direct_error.log" | Write-Host
                        }
                        exit 1
                    }
                                 } else {
                     Write-Host "ERROR: Failed to start Flask process"
                     exit 1
                 }
                 
             } catch {
                 Write-Host "EXCEPTION during direct startup: $($_.Exception.Message)"
                 Write-Host "Full exception: $_"
                 exit 1
             }
        } else {
            Write-Host "PASS: Service installed and started successfully via scheduled task"
        }
        
                 Write-Host ""
         Write-Host "=== STARTUP COMPLETED ==="
         if ($serviceStarted) {
             Write-Host "Method: Windows Scheduled Task"
             Write-Host "Management: Use scripts\manage_production_service.ps1"
             Write-Host "PASS: Production deployment completed successfully (service method)"
         } else {
             Write-Host "Method: Direct Python Process"
             Write-Host "Process ID file: production_direct.pid"
             Write-Host "Logs: production_direct.log, production_direct_error.log"
             Write-Host "PASS: Production deployment completed successfully (direct method)"
         }
         
         # Ensure we exit with success code since the app is running
         exit 0
      shell: powershell
        
    - name: Configure Windows Firewall for port 5000
      run: |
        Write-Host "Configuring Windows Firewall for port 5000..."
        
        try {
            # Remove any existing rules for port 5000
            Remove-NetFirewallRule -DisplayName "Flask Training App Port 5000" -ErrorAction SilentlyContinue
            
            # Add inbound rule for port 5000
            New-NetFirewallRule -DisplayName "Flask Training App Port 5000" -Direction Inbound -Protocol TCP -LocalPort 5000 -Action Allow -Profile Any
            
            Write-Host "PASS: Firewall configured for port 5000"
        } catch {
            Write-Host "WARNING: Could not configure firewall (requires admin privileges)"
            Write-Host "   Error: $($_.Exception.Message)"
            Write-Host "   This is OK if the firewall rule already exists or firewall is disabled"
            
            # Check if the port is already accessible
            try {
                $response = Invoke-WebRequest -Uri "http://localhost:5000" -UseBasicParsing -TimeoutSec 5 -ErrorAction Stop
                Write-Host "PASS: Application is accessible on port 5000 despite firewall warning"
            } catch {
                Write-Host "WARNING: Application may not be accessible externally without firewall rule"
                Write-Host "   You may need to manually configure firewall or run deployment as administrator"
            }
        }
      shell: powershell
        
    - name: Install maintenance task
      run: |
        Write-Host "Installing maintenance task..."
        try {
            powershell -ExecutionPolicy Bypass -File "scripts\manage_maintenance.ps1" -Action install
            Write-Host "Maintenance task installed - runs daily at 3:00 AM"
        } catch {
            Write-Host "WARNING: Failed to install maintenance task"
            Write-Host "Install manually: manage_app.bat maintenance-install"
        }
      shell: powershell
        
    - name: Configure Seq logging server (if installed)
      run: |
        Write-Host "Checking for Seq logging server..."
        
        # Check if Seq is installed
        $seqService = Get-Service -Name "Seq" -ErrorAction SilentlyContinue
        if ($seqService) {
            Write-Host "Seq found - configuring..."
            
            # Seq is configured - no changes needed
            Write-Host "Seq configuration: Authentication enabled with admin user"
            Write-Host "Note: Flask app will need Seq credentials to send logs"
            
            # Start Seq service
            if ($seqService.Status -ne "Running") {
                try {
                    Start-Service -Name "Seq"
                    Write-Host "Seq service started"
                } catch {
                    Write-Host "WARNING: Could not start Seq service: $_"
                }
            } else {
                Write-Host "Seq service is already running"
            }
            
            # Configure firewall
            try {
                Remove-NetFirewallRule -DisplayName "Seq Web Interface Port 5341" -ErrorAction SilentlyContinue
                New-NetFirewallRule -DisplayName "Seq Web Interface Port 5341" -Direction Inbound -Protocol TCP -LocalPort 5341 -Action Allow -Profile Any
                Write-Host "Firewall configured for Seq on port 5341"
            } catch {
                Write-Host "WARNING: Could not configure firewall for Seq"
            }
            
            Write-Host "Seq ready - Web interface: http://localhost:5341"
        } else {
            Write-Host "Seq not installed - logging will use file-only mode"
            Write-Host "To install Seq manually: Download from https://datalust.co/download"
        }
      shell: powershell
        
    - name: Verify production deployment
      run: |
        Write-Host "=== POST-DEPLOYMENT VERIFICATION ==="
        
        # Wait for application to start
        Write-Host "Waiting for application to start..."
        Start-Sleep -Seconds 15
        
        # Check service status using our management script
        $scriptPath = "scripts\manage_production_service.ps1"
        if (Test-Path $scriptPath) {
            Write-Host "Checking service status..."
            try {
                & powershell.exe -ExecutionPolicy Bypass -File $scriptPath -Action status
            } catch {
                Write-Host "Service status check failed: $_"
            }
        }
        
        # Check if Flask process is running
        Write-Host "`nChecking Flask processes..."
        $flaskProcesses = Get-WmiObject Win32_Process | Where-Object { 
            $_.CommandLine -and $_.CommandLine -match "start_production\.py"
        }
        
        $flaskRunning = $false
        
        if ($flaskProcesses) {
            Write-Host "PASS: Flask process found via process search"
            $flaskProcesses | ForEach-Object { 
                Write-Host "  PID: $($_.ProcessId), Command: $($_.CommandLine)"
            }
            $flaskRunning = $true
        }
        
        # Also check for direct process using our PID file
        if (Test-Path "production_direct.pid") {
            $directPid = Get-Content "production_direct.pid" -ErrorAction SilentlyContinue
            if ($directPid) {
                $directProcess = Get-Process -Id $directPid -ErrorAction SilentlyContinue
                if ($directProcess) {
                    Write-Host "PASS: Direct Flask process found (PID: $directPid)"
                    $flaskRunning = $true
                } else {
                    Write-Host "WARNING: Direct process PID file exists but process not running"
                }
            }
        }
        
        if (-not $flaskRunning) {
            Write-Host "WARNING: No Flask process found via any method"
        }
        
        # Check if port 5000 is listening
        Write-Host "`nChecking port 5000 status..."
        $listeningPorts = netstat -ano | Where-Object { $_ -match ":5000.*LISTENING" }
        if ($listeningPorts) {
            Write-Host "PASS: Port 5000 is listening"
            $listeningPorts | ForEach-Object { Write-Host "  $_" }
        } else {
            Write-Host "FAIL: Port 5000 is not listening"
        }
        
        # Check firewall rules
        Write-Host "`nChecking firewall rules..."
        $firewallRule = Get-NetFirewallRule -DisplayName "Flask Training App Port 5000" -ErrorAction SilentlyContinue
        if ($firewallRule) {
            Write-Host "PASS: Firewall rule exists and is $($firewallRule.Enabled)"
        } else {
            Write-Host "WARNING: No firewall rule found for port 5000"
        }
        
        # Test local connectivity with multiple attempts
        Write-Host "`nTesting local connectivity..."
        $attempts = 0
        $maxAttempts = 6
        $connected = $false
        
        while ($attempts -lt $maxAttempts -and -not $connected) {
            $attempts++
            try {
                $response = Invoke-WebRequest -Uri "http://localhost:5000" -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
                Write-Host "PASS: Local connectivity works (Status: $($response.StatusCode))"
                $connected = $true
            } catch {
                Write-Host "Attempt $attempts/$maxAttempts failed: $($_.Exception.Message)"
                if ($attempts -lt $maxAttempts) {
                    Start-Sleep -Seconds 10
                }
            }
        }
        
        if (-not $connected) {
            Write-Host "FAIL: Local connectivity failed after $maxAttempts attempts"
            
            # Show recent log entries if available
            $logFile = "production.log"
            if (Test-Path $logFile) {
                Write-Host "`nRecent production log entries:"
                Get-Content $logFile -Tail 10 | ForEach-Object { Write-Host "  $_" }
            }
        }
        
        # Test network connectivity from localhost
        Write-Host "`nTesting network connectivity..."
        $computerName = $env:COMPUTERNAME
        try {
            $response = Invoke-WebRequest -Uri "http://${computerName}:5000" -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
            Write-Host "PASS: Network connectivity works (Status: $($response.StatusCode))"
        } catch {
            Write-Host "FAIL: Network connectivity failed: $($_.Exception.Message)"
        }
        
        Write-Host "`n=== ACCESS INFORMATION ==="
        Write-Host "Application should be accessible at:"
        Write-Host "  http://${computerName}:5000"
        Write-Host "  http://azulimpbi01:5000"
        
        # Get IP addresses
        $ipAddresses = Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias "Ethernet*" | Where-Object { $_.IPAddress -ne "127.0.0.1" }
        foreach ($ip in $ipAddresses) {
            Write-Host "  http://$($ip.IPAddress):5000"
        }
        
        Write-Host "`n=== SERVICE MANAGEMENT ==="
        Write-Host "To manage the service manually, use:"
        Write-Host "  powershell -ExecutionPolicy Bypass -File scripts\manage_production_service.ps1 -Action status"
        Write-Host "  powershell -ExecutionPolicy Bypass -File scripts\manage_production_service.ps1 -Action restart"
        Write-Host "  powershell -ExecutionPolicy Bypass -File scripts\manage_production_service.ps1 -Action stop"
        Write-Host "================================"
      shell: powershell
        
    - name: Health check
      run: |
        Write-Host "Running final health check..."
        Start-Sleep -Seconds 5
        
        try {
            $response = Invoke-WebRequest -Uri "http://localhost:5000" -UseBasicParsing -TimeoutSec 15 -ErrorAction Stop
            Write-Host "PASS: Health check successful (Status: $($response.StatusCode))"
            Write-Host "PASS: Production deployment completed successfully!"
        } catch {
            Write-Host "FAIL: Health check failed: $($_.Exception.Message)"
            Write-Host "The application may still be starting up. Check the service status manually."
            
            # Don't fail the deployment if health check fails, as the service might just be slow to start
            Write-Host "Deployment completed - please verify manually using:"
            Write-Host "  powershell -File scripts\manage_production_service.ps1 -Action status"
        }
      shell: powershell

  notify:
    runs-on: self-hosted
    needs: [deploy-development, deploy-staging, deploy-production]
    if: always()
    name: Notify Deployment Status
    
    steps:
    - name: Deployment Status Summary
      run: |
        Write-Host "=== Deployment Summary ==="
        Write-Host "Development: ${{ needs.deploy-development.result }}"
        Write-Host "Staging: ${{ needs.deploy-staging.result }}"
        Write-Host "Production: ${{ needs.deploy-production.result }}"
        Write-Host ""
        
        $prodResult = "${{ needs.deploy-production.result }}"
        $stagingResult = "${{ needs.deploy-staging.result }}"
        
        if ($prodResult -eq "success") {
            Write-Host "SUCCESS: Production deployment completed successfully!"
        } elseif ($stagingResult -eq "success") {
            Write-Host "PASS: Staging deployment completed - ready for production"
        } else {
            Write-Host "WARNING: Deployment pipeline completed with issues"
        }
      shell: powershell 